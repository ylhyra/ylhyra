import { Deck } from "flashcards/flashcards/actions/deck/deck";
import { ClassifiedCards } from "flashcards/flashcards/actions/createCards/classifyCards";
import { loadCardsIntoSession } from "flashcards/flashcards/actions/session/loadCardsIntoSession";
import { Card } from "flashcards/flashcards/actions/card/card";

/** Class to assist with randomly choosing from the allowed decks */
export class CardChooser {
  classifiedCards: ClassifiedCards;
  counter = 0;

  constructor(deck: Deck) {
    this.classifiedCards = new ClassifiedCards(deck);
  }

  /** Chooses a card to add to the current session */
  run() {
    let card: Card;
    //TODO!
    if (this.classifiedCards.newCards.length > 0 && this.counter % 3 === 0) {
      card = this.classifiedCards.newCards.shift()!;
    } else {
      card = this.classifiedCards.overdueGood.shift()!;
    }
    loadCardsIntoSession([card]);
  }

  // run(): Card[] {
  //   let chosenCards: Card[] = [];
  //   const cardsToCreate = Math.min(CARDS_TO_CREATE, this.countAllCards);
  //   const newCardEvery = this.newCardEvery;
  //   console.groupCollapsed("See chosen cards");
  //   for (let i = 0; i < cardsToCreate; i++) {
  //     const shouldBeNewCard =
  //       (i % newCardEvery === Math.round(newCardEvery * 0.75) ||
  //         !this.areOldCardsRemaining) &&
  //       this.areNewCardsRemaining;
  //     const card = this.getCardOfType(shouldBeNewCard ? "NEW" : "OVERDUE");
  //     if (!card) continue;
  //     chosenCards.push(card);
  //     log(
  //       (isNewRow(card) ? "NEW" : "OLD") +
  //         ` "${card.row.deck.title}" > ` +
  //         `"${printWord(card)?.slice(0, 30)}" `,
  //     );
  //   }
  //   console.groupEnd();
  //
  //   /**
  //    * If no cards generated by the above, we simply return cards that are not
  //    * overdue.
  //    */
  //   if (chosenCards.length === 0) {
  //     // TODO: What if deck is empty
  //     // chosenCards = veryRecentlySeenSortedLast(sortCardsByScore(notOverdue));
  //     // console.error("No cards generated. Falling back to all cards.");
  //   }
  //
  //   return chosenCards;
  // }
  //
  // get countAllCards() {
  //   return this.classifiedCards.reduce(
  //     (acc, curr) => acc + curr.countAllCards,
  //     0,
  //   );
  // }
  //
  // /** Interval of new cards */
  // get newCardEvery() {
  //   const badCount = this.classifiedCards.reduce(
  //     (acc, curr) => acc + curr.overdueBad.length,
  //     0,
  //   );
  //
  //   const extremelyBadCount = this.classifiedCards.reduce(
  //     (acc, curr) =>
  //       acc + curr.overdueBad.filter((c) => c.score === Rating.BAD).length,
  //     0,
  //   );
  //
  //   if (extremelyBadCount > 10) {
  //     return 12;
  //   } else if (badCount > 15) {
  //     return 8;
  //   } else {
  //     return 4;
  //   }
  // }
  //
  // get areNewCardsRemaining() {
  //   return this.classifiedCards.some((j) => j.countCardsOfType("NEW") > 0);
  // }
  //
  // get areOldCardsRemaining() {
  //   return this.classifiedCards.some((j) => {
  //     return j.countCardsOfType("OVERDUE") > 0;
  //   });
  // }
  //
  // getCardOfType(type: "NEW" | "OVERDUE"): Card | undefined {
  //   const deck = chooseDependingOnRelativeProbability(
  //     this.classifiedCards,
  //     (deck) => {
  //       return deck.getRelativeProbabilityOfThisDeckBeingChosen(type);
  //     },
  //   );
  //   if (deck) {
  //     return deck.getCardOfType(type);
  //   }
  // }
}
