import { Deck } from "flashcards/flashcards/actions/deck/deck";
import { Card } from "flashcards/flashcards/actions/card/card";
import { isAllowed } from "flashcards/flashcards/actions/card/cardIsAllowed";
import {
  isInSchedule,
  isOverdue,
  wasRowVeryRecentlySeen,
  isUnseenSiblingOfANonGoodCard,
  timeSinceRowWasSeen,
} from "flashcards/flashcards/actions/card/cardSchedule";
import {
  isBelowGood,
  isBad,
} from "flashcards/flashcards/actions/card/cardDifficulty";
import { minutes } from "modules/time";
import { sortCards } from "flashcards/flashcards/actions/createCards/functions";

export const CARDS_TO_CREATE = 30;

class ClassifiedCard {
  isNew?: boolean;
  isOverdueGood?: boolean;
  isOverdueBad?: boolean;
  constructor(public card: Card) {}
  get isOverdue() {
    return this.isOverdueGood || this.isOverdueBad;
  }
}

export class CardChooser {
  classifiedCards: ClassifiedCard[] = [];

  constructor(deck: Deck) {
    deck.cards
      .filter((card) => isAllowed(card))
      .forEach((card) => {
        const classifiedCard = new ClassifiedCard(card);

        if (!isInSchedule(card)) {
          classifiedCard.isNew = true;
        }

        // Overdue
        else if (isOverdue(card) && !wasRowVeryRecentlySeen(card)) {
          if (isBelowGood(card) || isUnseenSiblingOfANonGoodCard(card)) {
            classifiedCard.isOverdueBad = true;
          } else {
            classifiedCard.isOverdueGood = true;
          }
        }

        // Very bad cards seen more than 20 minutes ago are also added to the overdue pile
        else if (
          isBad(card) &&
          (timeSinceRowWasSeen(card) || 0) > 20 * minutes
        ) {
          classifiedCard.isOverdueBad = true;
        }

        this.classifiedCards.push(classifiedCard);
      });

    this.overdueBad = sortCards(this.overdueBad, deck, "OLD");
    this.overdueGood = sortCards(this.overdueGood, deck, "OLD");
    this.newCards = sortCards(this.newCards, deck, "NEW");
  }

  // /** Chooses a card to add to the current session */
  // run() {
  //   let card: Card | undefined;
  //   //TODO!
  //   if (this.newCards.length > 0 && this.counter % 3 === 0) {
  //     card = this.newCards.shift();
  //   } else {
  //     card = this.overdueGood.shift();
  //   }
  //
  //   if (!card) {
  //     console.error("Failed to generate :(");
  //   } else {
  //     console.log(card);
  //     loadCardsIntoSession([card]);
  //   }
  // }

  run(): Card[] {
    let chosenCards: Card[] = [];
    const newCardEvery = 3;
    console.group("Chosen cards");
    for (let i = 0; i < CARDS_TO_CREATE; i++) {
      const shouldBeNewCard =
        (i % newCardEvery === Math.round(newCardEvery * 0.75) ||
          !this.classifiedCards.some((c) => c.isOverdue)) &&
        this.classifiedCards.some((c) => c.isNew);

      // const card = this.getCardOfType(shouldBeNewCard ? "NEW" : "OVERDUE");
      // if (!card) continue;
      // chosenCards.push(card);
      // log(
      //   (isNewRow(card) ? "NEW" : "OLD") +
      //     ` "${card.row.deck.title}" > ` +
      //     `"${printWord(card)?.slice(0, 30)}" `,
      // );
    }
    console.groupEnd();

    /**
     * If no cards generated by the above, we simply return cards that are not
     * overdue.
     */
    if (chosenCards.length === 0) {
      // TODO: What if deck is empty
      // chosenCards = veryRecentlySeenSortedLast(sortCardsByScore(notOverdue));
      // console.error("No cards generated. Falling back to all cards.");
    }

    return chosenCards;
  }

  // get countAllCards() {
  //   return this.classifiedCards.reduce(
  //     (acc, curr) => acc + curr.countAllCards,
  //     0,
  //   );
  // }
  //
  // /** Interval of new cards */
  // get newCardEvery() {
  //   const badCount = this.classifiedCards.reduce(
  //     (acc, curr) => acc + curr.overdueBad.length,
  //     0,
  //   );
  //
  //   const extremelyBadCount = this.classifiedCards.reduce(
  //     (acc, curr) =>
  //       acc + curr.overdueBad.filter((c) => c.score === Rating.BAD).length,
  //     0,
  //   );
  //
  //   if (extremelyBadCount > 10) {
  //     return 12;
  //   } else if (badCount > 15) {
  //     return 8;
  //   } else {
  //     return 4;
  //   }
  // }
  // getCardOfType(type: "NEW" | "OVERDUE"): Card | undefined {
  //   const deck = chooseDependingOnRelativeProbability(
  //     this.classifiedCards,
  //     (deck) => {
  //       return deck.getRelativeProbabilityOfThisDeckBeingChosen(type);
  //     },
  //   );
  //   if (deck) {
  //     return deck.getCardOfType(type);
  //   }
  // }
}
