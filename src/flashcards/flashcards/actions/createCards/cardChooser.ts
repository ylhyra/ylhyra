import { Deck } from "flashcards/flashcards/actions/deck/deck";
import { loadCardsIntoSession } from "flashcards/flashcards/actions/session/loadCardsIntoSession";
import { Card } from "flashcards/flashcards/actions/card/card";
import { isAllowed } from "flashcards/flashcards/actions/card/cardIsAllowed";
import {
  isInSchedule,
  isOverdue,
  wasRowVeryRecentlySeen,
  isUnseenSiblingOfANonGoodCard,
  timeSinceRowWasSeen,
} from "flashcards/flashcards/actions/card/cardSchedule";
import {
  isBelowGood,
  isBad,
} from "flashcards/flashcards/actions/card/cardDifficulty";
import { minutes } from "modules/time";
import { sortCards } from "flashcards/flashcards/actions/createCards/functions";

export class CardChooser {
  counter = 0;

  overdueGood: Card[] = [];
  overdueBad: Card[] = [];
  notOverdue: Card[] = [];
  newCards: Card[] = [];

  constructor(deck: Deck) {
    deck.cards
      .filter((card) => isAllowed(card))
      .forEach((card) => {
        if (!isInSchedule(card)) {
          this.newCards.push(card);
        }

        // Overdue
        else if (isOverdue(card) && !wasRowVeryRecentlySeen(card)) {
          if (isBelowGood(card) || isUnseenSiblingOfANonGoodCard(card)) {
            this.overdueBad.push(card);
          } else {
            this.overdueGood.push(card);
          }
        }

        // Very bad cards seen more than 20 minutes ago are also added to the overdue pile
        else if (
          isBad(card) &&
          (timeSinceRowWasSeen(card) || 0) > 20 * minutes
        ) {
          return this.overdueBad.push(card);
        } else {
          this.notOverdue.push(card);
        }
      });

    this.overdueBad = sortCards(this.overdueBad, deck, "OLD");
    this.overdueGood = sortCards(this.overdueGood, deck, "OLD");
    this.newCards = sortCards(this.newCards, deck, "NEW");
  }

  /** Chooses a card to add to the current session */
  run() {
    let card: Card;
    //TODO!
    if (this.newCards.length > 0 && this.counter % 3 === 0) {
      card = this.newCards.shift()!;
    } else {
      card = this.overdueGood.shift()!;
    }
    loadCardsIntoSession([card]);
  }

  // run(): Card[] {
  //   let chosenCards: Card[] = [];
  //   const cardsToCreate = Math.min(CARDS_TO_CREATE, this.countAllCards);
  //   const newCardEvery = this.newCardEvery;
  //   console.groupCollapsed("See chosen cards");
  //   for (let i = 0; i < cardsToCreate; i++) {
  //     const shouldBeNewCard =
  //       (i % newCardEvery === Math.round(newCardEvery * 0.75) ||
  //         !this.areOldCardsRemaining) &&
  //       this.areNewCardsRemaining;
  //     const card = this.getCardOfType(shouldBeNewCard ? "NEW" : "OVERDUE");
  //     if (!card) continue;
  //     chosenCards.push(card);
  //     log(
  //       (isNewRow(card) ? "NEW" : "OLD") +
  //         ` "${card.row.deck.title}" > ` +
  //         `"${printWord(card)?.slice(0, 30)}" `,
  //     );
  //   }
  //   console.groupEnd();
  //
  //   /**
  //    * If no cards generated by the above, we simply return cards that are not
  //    * overdue.
  //    */
  //   if (chosenCards.length === 0) {
  //     // TODO: What if deck is empty
  //     // chosenCards = veryRecentlySeenSortedLast(sortCardsByScore(notOverdue));
  //     // console.error("No cards generated. Falling back to all cards.");
  //   }
  //
  //   return chosenCards;
  // }
  //
  // get countAllCards() {
  //   return this.classifiedCards.reduce(
  //     (acc, curr) => acc + curr.countAllCards,
  //     0,
  //   );
  // }
  //
  // /** Interval of new cards */
  // get newCardEvery() {
  //   const badCount = this.classifiedCards.reduce(
  //     (acc, curr) => acc + curr.overdueBad.length,
  //     0,
  //   );
  //
  //   const extremelyBadCount = this.classifiedCards.reduce(
  //     (acc, curr) =>
  //       acc + curr.overdueBad.filter((c) => c.score === Rating.BAD).length,
  //     0,
  //   );
  //
  //   if (extremelyBadCount > 10) {
  //     return 12;
  //   } else if (badCount > 15) {
  //     return 8;
  //   } else {
  //     return 4;
  //   }
  // }
  //
  // get areNewCardsRemaining() {
  //   return this.classifiedCards.some((j) => j.countCardsOfType("NEW") > 0);
  // }
  //
  // get areOldCardsRemaining() {
  //   return this.classifiedCards.some((j) => {
  //     return j.countCardsOfType("OVERDUE") > 0;
  //   });
  // }
  //
  // getCardOfType(type: "NEW" | "OVERDUE"): Card | undefined {
  //   const deck = chooseDependingOnRelativeProbability(
  //     this.classifiedCards,
  //     (deck) => {
  //       return deck.getRelativeProbabilityOfThisDeckBeingChosen(type);
  //     },
  //   );
  //   if (deck) {
  //     return deck.getCardOfType(type);
  //   }
  // }
}
