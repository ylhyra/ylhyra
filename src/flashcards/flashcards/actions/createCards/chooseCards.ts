import { Card } from "flashcards/flashcards/actions/card/card";
import { ClassifiedCardsInDeck } from "flashcards/flashcards/actions/createCards/classifiedCardsInDeck";
import { printWord } from "flashcards/flashcards/actions/functions";
import { Session } from "flashcards/flashcards/actions/session/session";
import { log } from "modules/log";
import { chooseDependingOnRelativeProbability } from "modules/probability";
import { isNewRow } from "flashcards/flashcards/actions/card/cardSchedule";
import { Rating } from "flashcards/flashcards/types";

export const CARDS_TO_CREATE = 30;

/** Class to assist with randomly choosing from the allowed decks */
export class ChooseCards {
  classifiedDecks: ClassifiedCardsInDeck[];

  constructor(public session: Session) {
    this.classifiedDecks = session.allowedDecks.map(
      (deck) => new ClassifiedCardsInDeck(deck, this),
    );
  }

  run(): Card[] {
    let chosenCards: Card[] = [];
    const cardsToCreate = Math.min(CARDS_TO_CREATE, this.countAllCards);
    const newCardEvery = this.newCardEvery;
    console.groupCollapsed("See chosen cards");
    for (let i = 0; i < cardsToCreate; i++) {
      const shouldBeNewCard =
        (i % newCardEvery === 0 || !this.areOldCardsRemaining) &&
        this.areNewCardsRemaining;
      const card = this.getCardOfType(shouldBeNewCard ? "NEW" : "OVERDUE");
      if (!card) continue;
      chosenCards.push(card);
      log(
        (isNewRow(card) ? "NEW" : "OLD") +
          ` "${card.row.deck.title}" > ` +
          `"${printWord(card)?.slice(0, 30)}" `,
      );
    }
    console.groupEnd();

    /** If no cards generated by the above, we simply return cards that are not overdue. */
    if (chosenCards.length === 0) {
      // TODO: What if deck is empty
      // chosenCards = veryRecentlySeenSortedLast(sortCardsByScore(notOverdue));
      // console.error("No cards generated. Falling back to all cards.");
    }

    return chosenCards;
  }

  get countAllCards() {
    return this.classifiedDecks.reduce(
      (acc, curr) => acc + curr.countAllCards,
      0,
    );
  }

  /** Interval of new cards */
  get newCardEvery() {
    if (this.session.allowedDecks[0]?.settings.frequencyOfNewCards == 0) {
      return 0;
    }
    return 2;
    const badCount = this.classifiedDecks.reduce(
      (acc, curr) => acc + curr.overdueBad.length,
      0,
    );

    const extremelyBadCount = this.classifiedDecks.reduce(
      (acc, curr) =>
        acc + curr.overdueBad.filter((c) => c.score === Rating.BAD).length,
      0,
    );

    if (extremelyBadCount > 10) {
      return 12;
    } else if (badCount > 15) {
      return 8;
    } else {
      return 4;
    }
  }

  get areNewCardsRemaining() {
    return this.classifiedDecks.some((j) => j.countCardsOfType("NEW") > 0);
  }

  get areOldCardsRemaining() {
    return this.classifiedDecks.some((j) => {
      return j.countCardsOfType("OVERDUE") > 0;
    });
  }

  getCardOfType(type: "NEW" | "OVERDUE"): Card | undefined {
    const deck = chooseDependingOnRelativeProbability(
      this.classifiedDecks,
      (deck) => {
        return deck.getRelativeProbabilityOfThisDeckBeingChosen(type);
      },
    );
    if (deck) {
      return deck.getCardOfType(type);
    }
  }
}

// if (process.env.quokka) {
//   const session = setupTestSession();
//   const out = new ChooseCards(session).run();
//   console.log(out);
// }
