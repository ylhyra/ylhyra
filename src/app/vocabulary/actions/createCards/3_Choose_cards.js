import { CARDS_TO_CREATE } from "app/vocabulary/actions/createCards/index";
import { SortIdsByScore } from "app/vocabulary/actions/createCards/functions";
import { log } from "app/app/functions/log";
import { printWord } from "app/vocabulary/actions/functions";

export default ({
  overdue_bad_ids,
  overdue_good_ids,
  not_overdue_bad_cards_ids,
  not_overdue_semi_bad_cards_ids,
  new_card_ids,
  very_recently_seen_not_overdue_bad_cards,
  not_overdue_ids,
}) => {
  let total_options = sumOfArrayLengths(
    overdue_bad_ids,
    overdue_good_ids,
    not_overdue_bad_cards_ids,
    not_overdue_semi_bad_cards_ids,
    new_card_ids
  );

  let chosen_ids = [];
  let newCardEvery = 3;
  let bad_count = sumOfArrayLengths(overdue_bad_ids, not_overdue_bad_cards_ids);
  if (bad_count > 15) {
    newCardEvery = 5;
  }
  if (bad_count > 40) {
    newCardEvery = 20;
  }

  /*
    Loop to select chosen cards
  */
  for (
    let i = 0;
    chosen_ids.length < Math.min(CARDS_TO_CREATE, total_options) && i < 1000;
    i++
  ) {
    if (!isEmpty(overdue_good_ids)) {
      chosen_ids.push(overdue_good_ids.shift());
    }
    if (!isEmpty(overdue_bad_ids)) {
      chosen_ids.push(overdue_bad_ids.shift());
    }
    if (i % newCardEvery === 0 && !isEmpty(new_card_ids)) {
      chosen_ids.push(new_card_ids.shift());
    }

    /* Occasionally show a bad card that the user saw in the last session */
    if (i % 4 === 2) {
      if (!isEmpty(very_recently_seen_not_overdue_bad_cards)) {
        log(
          `Very recently seen word "${printWord(
            very_recently_seen_not_overdue_bad_cards[0]
          )}" added`
        );
        chosen_ids.push(very_recently_seen_not_overdue_bad_cards.shift());
      }
    }

    if (
      (isEmpty(overdue_good_ids) && isEmpty(overdue_bad_ids)) ||
      i % 2 === 1
    ) {
      if (!isEmpty(not_overdue_bad_cards_ids)) {
        log(
          `Not overdue bad card "${printWord(
            not_overdue_bad_cards_ids[0]
          )}" added`
        );
        chosen_ids.push(not_overdue_bad_cards_ids.shift());
      }
    }
    if (isEmpty(overdue_good_ids) && isEmpty(overdue_bad_ids)) {
      if (i % 4 === 4 - 1 && !isEmpty(not_overdue_semi_bad_cards_ids)) {
        log(
          `Not overdue good card "${printWord(
            not_overdue_semi_bad_cards_ids[0]
          )}" added`
        );
        chosen_ids.push(not_overdue_semi_bad_cards_ids.shift());
      }
    }
  }

  /**
   * If no cards generated by the above,
   * we simply return cards that are not overdue.
   */
  if (chosen_ids.length === 0) {
    chosen_ids = SortIdsByScore(not_overdue_ids);
  }

  return chosen_ids;
};

const isEmpty = (array) => array.length === 0;
const sumOfArrayLengths = (...arrays) => {
  let length = 0;
  arrays.forEach((a) => (length += a.length));
  return length;
};
