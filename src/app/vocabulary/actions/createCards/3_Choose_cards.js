import { CARDS_TO_CREATE } from "app/vocabulary/actions/createCards/index";
import { sortCardsByScore } from "app/vocabulary/actions/createCards/functions";
import { log } from "app/app/functions/log";
import OldCards from "app/vocabulary/actions/createCards/1_Old_cards";
import NewCards from "app/vocabulary/actions/createCards/2_New_cards";

export default () => {
  const {
    /** @type {Array.<Card>} */
    overdue_bad,
    /** @type {Array.<Card>} */
    overdue_good,
    /** @type {Array.<Card>} */
    not_overdue_bad,
    /** @type {Array.<Card>} */
    not_overdue_semi_bad,
    /** @type {Array.<Card>} */
    very_recently_seen_not_overdue_bad,
    /** @type {Array.<Card>} */
    not_overdue,
  } = OldCards();

  /** @type {Array.<Card>} */
  const new_cards = NewCards();

  let total_options = sumOfArrayLengths(
    overdue_bad,
    overdue_good,
    not_overdue_bad,
    not_overdue_semi_bad,
    new_cards
  );

  /** @type {Array.<Card>} */
  let chosen_cards = [];

  let newCardEvery = 3;
  let bad_count = sumOfArrayLengths(overdue_bad, not_overdue_bad);
  if (bad_count > 15) {
    newCardEvery = 5;
  }
  if (bad_count > 40) {
    newCardEvery = 20;
  }

  /*
    Loop to select chosen cards
  */
  for (
    let i = 0;
    chosen_cards.length < Math.min(CARDS_TO_CREATE, total_options) && i < 1000;
    i++
  ) {
    if (!isEmpty(overdue_good)) {
      chosen_cards.push(overdue_good.shift());
    }
    if (!isEmpty(overdue_bad)) {
      chosen_cards.push(overdue_bad.shift());
    }
    if (i % newCardEvery === 0 && !isEmpty(new_cards)) {
      chosen_cards.push(new_cards.shift());
    }

    /* Occasionally show a bad card that the user saw in the last session */
    if (i % 4 === 2) {
      if (!isEmpty(very_recently_seen_not_overdue_bad)) {
        log(
          `Very recently seen word "${very_recently_seen_not_overdue_bad[0].printWord()}" added`
        );
        chosen_cards.push(very_recently_seen_not_overdue_bad.shift());
      }
    }

    /* Not overdue bad cards */
    if ((isEmpty(overdue_good) && isEmpty(overdue_bad)) || i % 2 === 1) {
      if (!isEmpty(not_overdue_bad)) {
        log(`Not overdue bad card "${not_overdue_bad[0].printWord()}" added`);
        chosen_cards.push(not_overdue_bad.shift());
      }
    }

    /* Not overdue good cards */
    if (isEmpty(overdue_good) && isEmpty(overdue_bad)) {
      if (i % 4 === 4 - 1 && !isEmpty(not_overdue_semi_bad)) {
        log(
          `Not overdue good card "${not_overdue_semi_bad[0].printWord()}" added`
        );
        chosen_cards.push(not_overdue_semi_bad.shift());
      }
    }
  }

  /**
   * If no cards generated by the above,
   * we simply return cards that are not overdue.
   */
  if (chosen_cards.length === 0) {
    chosen_cards = sortCardsByScore(not_overdue);
  }

  return chosen_cards;
};

export const isEmpty = (array) => array.length === 0;
export const sumOfArrayLengths = (...arrays) => {
  let length = 0;
  arrays.forEach((a) => (length += a.length));
  return length;
};
