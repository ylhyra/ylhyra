"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sumOfArrayLengths = exports.isEmpty = void 0;
const isDev_1 = require("app/app/functions/isDev");
const log_1 = require("app/app/functions/log");
const _1_Old_cards_1 = __importDefault(require("app/vocabulary/actions/createCards/1_Old_cards"));
const _2_New_cards_1 = __importDefault(require("app/vocabulary/actions/createCards/2_New_cards"));
const functions_1 = require("app/vocabulary/actions/createCards/functions");
const index_1 = require("app/vocabulary/actions/createCards/index");
const functions_2 = require("app/vocabulary/actions/functions");
exports.default = (options) => {
    /**
     * Chosen_cards starts out as an array of nulls;
     * the slots will later be filled.
     */
    let chosen_cards = new Array(index_1.CARDS_TO_CREATE).fill(null);
    /* Helper function to add to chosen_cards */
    const add = (arr, desc, pos) => {
        if (!(0, exports.isEmpty)(arr)) {
            if (pos === undefined) {
                pos = chosen_cards.findIndex((j) => j === null);
                if (pos < 0) {
                    pos = chosen_cards.length;
                }
            }
            (0, log_1.log)(`${desc} card "${(0, functions_2.printWord)(arr[0])}" added at position ${pos + 1}`);
            chosen_cards[pos] = arr.shift();
        }
    };
    const { overdue_bad, overdue_good, not_overdue } = (0, _1_Old_cards_1.default)();
    const new_cards = (0, _2_New_cards_1.default)(options);
    let total_options = (0, exports.sumOfArrayLengths)(overdue_bad, overdue_good);
    let bad_count = (0, exports.sumOfArrayLengths)(overdue_bad);
    isDev_1.isDev &&
        (0, log_1.logDev)({
            overdue_good: Object.assign({}, overdue_good),
            overdue_bad: Object.assign({}, overdue_bad),
            new_cards: Object.assign({}, new_cards),
            not_overdue: Object.assign({}, not_overdue),
        });
    let newCardEvery = 2;
    if (bad_count > 100) {
        newCardEvery = 7;
    }
    else if (bad_count > 40) {
        newCardEvery = 5;
    }
    else if (bad_count > 15) {
        newCardEvery = 4;
    }
    /*
      Start by spreading new cards into chosen_cards with a given interval.
      Unfilled slots are left as null.
    */
    for (let pos = newCardEvery; pos < index_1.CARDS_TO_CREATE && !(0, exports.isEmpty)(new_cards); pos += newCardEvery) {
        add(new_cards, "New", pos);
    }
    /*
      Now scheduled cards are placed into the slots left over
    */
    for (let i = 0; chosen_cards.filter(Boolean).length <
        Math.min(index_1.CARDS_TO_CREATE, total_options) && i < 1000; i++) {
        add(overdue_good, "Overdue good");
        add(overdue_bad, "Overdue bad");
    }
    chosen_cards = chosen_cards.filter(Boolean);
    if (chosen_cards.length < index_1.CARDS_TO_CREATE) {
        chosen_cards = chosen_cards.concat(new_cards).slice(0, index_1.CARDS_TO_CREATE);
    }
    /**
     * If no cards generated by the above,
     * we simply return cards that are not overdue.
     */
    if (chosen_cards.length === 0) {
        chosen_cards = (0, functions_1.veryRecentlySeenSortedLast)((0, functions_1.sortCardsByScore)(not_overdue));
        console.error("No cards generated. Falling back to all cards.");
    }
    return chosen_cards;
};
const isEmpty = (array) => array.length === 0;
exports.isEmpty = isEmpty;
const sumOfArrayLengths = (...arrays) => {
    let length = 0;
    arrays.forEach((a) => (length += a.length));
    return length;
};
exports.sumOfArrayLengths = sumOfArrayLengths;
