import { CARDS_TO_CREATE } from "app/vocabulary/actions/createCards/index";
import {
  sortCardsByScore,
  veryRecentlySeenSortedLast,
} from "app/vocabulary/actions/createCards/functions";
import { log } from "app/app/functions/log";
import OldCards from "app/vocabulary/actions/createCards/1_Old_cards";
import NewCards from "app/vocabulary/actions/createCards/2_New_cards";

export default () => {
  const {
    /** @type {Array.<Card>} */
    overdue_bad,
    /** @type {Array.<Card>} */
    overdue_good,
    /** @type {Array.<Card>} */
    not_overdue_bad,
    /** @type {Array.<Card>} */
    not_overdue_semi_bad,
    /** @type {Array.<Card>} */
    not_overdue,
  } = OldCards();

  /** @type {Array.<Card>} */
  const new_cards = NewCards();

  /** @type {Array.<Card>} */
  let chosen_cards = [];

  let total_options = sumOfArrayLengths(
    overdue_bad,
    overdue_good,
    not_overdue_bad,
    not_overdue_semi_bad,
    new_cards
  );

  let newCardEvery = 2;
  let bad_count = sumOfArrayLengths(overdue_bad, not_overdue_bad);
  if (bad_count > 15) {
    newCardEvery = 3;
  }
  if (bad_count > 40) {
    newCardEvery = 6;
  }

  console.log({
    overdue_good,
    overdue_bad,
    new_cards,
  });

  /*
    Loop to select chosen cards
  */
  for (
    let i = 0;
    chosen_cards.length < Math.min(CARDS_TO_CREATE, total_options) && i < 1000;
    i++
  ) {
    if (!isEmpty(overdue_good)) {
      chosen_cards.push(overdue_good.shift());
    }
    if (!isEmpty(overdue_bad)) {
      chosen_cards.push(overdue_bad.shift());
    }
    if (
      (i % newCardEvery === 0 ||
        (isEmpty(overdue_good) && isEmpty(overdue_bad))) &&
      !isEmpty(new_cards)
    ) {
      chosen_cards.push(new_cards.shift());
    }

    if (chosen_cards.length > 10) {
      /* Not overdue bad cards */
      if ((isEmpty(overdue_good) && isEmpty(overdue_bad)) || i % 2 === 1) {
        if (!isEmpty(not_overdue_bad)) {
          log(`Not overdue bad card "${not_overdue_bad[0].printWord()}" added`);
          chosen_cards.push(not_overdue_bad.shift());
        }
      }

      /* Not overdue good cards */
      if (isEmpty(overdue_good) && isEmpty(overdue_bad)) {
        if (i % 4 === 4 - 1 && !isEmpty(not_overdue_semi_bad)) {
          log(
            `Not overdue good card "${not_overdue_semi_bad[0].printWord()}" added`
          );
          chosen_cards.push(not_overdue_semi_bad.shift());
        }
      }
    }
  }

  /**
   * If no cards generated by the above,
   * we simply return cards that are not overdue.
   */
  if (chosen_cards.length === 0) {
    chosen_cards =
      [...not_overdue_bad, ...not_overdue_semi_bad, ...not_overdue]
      |> sortCardsByScore
      |> veryRecentlySeenSortedLast;
    console.error("No cards generated. Falling back to all cards.");
  }

  return chosen_cards;
};

export const isEmpty = (array) => array.length === 0;
export const sumOfArrayLengths = (...arrays) => {
  let length = 0;
  arrays.forEach((a) => (length += a.length));
  return length;
};
